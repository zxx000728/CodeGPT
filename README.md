# CodeGPT: A Code-Related Dialogue Dataset Generated by GPT and for GPT

[[English Version](README_EN.md)]

编程能力是ChatGPT的关键能力之一，要想复现ChatGPT，大量的代码训练数据不可或缺。但现有的代码训练数据大多难度较高，且缺少中文相关数据，模型训练效果通常不佳。为此，我们自动生成并从互联网上收集了大量不同难度的代码相关对话数据，用于训练GPT，提升GPT的编程能力，并在此公开32K条中文数据，称之为“CodeGPT-Dataset-V1-CN”。

## 方法介绍

考虑到代码难度对模型训练效果的影响，我们共收集了四种不同类型、不同难度的代码相关对话数据，收集方法如下：

1. Code-Basic：利用已有的LLM（例如付费API）生成各种编程语言的基础库函数相关的代码对话数据。Prompt类似“请为C语言中的XX函数生成一道非常简单的编程问题及对应的代码答案”，API会输出该基础库函数相关的问题-答案对，将问题作为用户输入，答案作为模型输出（Markdown格式），可得到一条对话数据。
2. Code-Medium：利用已有的LLM（例如付费API）生成中等难度的编程问题及答案，例如写入内容到文件、查找字符串子串、实现链表等，API同样会输出问题-答案对，将问题作为用户输入，答案作为模型输出（Markdown格式），可得到一条对话数据。
3. Code-LeetCode：从LeetCode上收集到的问题-答案对，此类问题通常难度较高。将问题作为用户输入，答案作为模型输出（Markdown格式），可得到一条对话数据。
4. Code-Text：从互联网上收集到的常见面试题及答案，此类问题并不涉及编程，而是侧重于对各种概念的理解。将问题作为用户输入，答案作为模型输出（文本形式），可得到一条对话数据。

## 数据公开

我们使用上述方法收集了大量代码相关的对话数据，现公开其中部分数据，称之为“CodeGPT-Dataset-V1-CN”，包含32K条中文对话数据，数据样例如下所示。

### 例1-Basic：

```json
{
    "system": "Assistant扮演一名对话机器人。User每次输入一个问题，Assistant做出相应回答。不使用任何插件。",
    "source": "CodeGPT",
    "language": "Chinese",
    "user": "这是关于C中abs的问题。编写一个程序，输入一个整数n，并输出n的绝对值。",
    "assistant": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    printf(\"%d\", abs(n));\n    return 0;\n}\n```",
    "thought": "这是关于C中abs的问题，该函数的函数描述为：返回一个整数的绝对值。",
    "command": "",
    "plugin": ""
}
```

### 例2-Medium：

```json
{
    "system": "Assistant扮演一名对话机器人。User每次输入一个问题，Assistant做出相应回答。不使用任何插件。",
    "source": "CodeGPT",
    "language": "Chinese",
    "user": "用C语言将整型数组按从小到大的顺序排序；",
    "assistant": "```c\n#include <stdio.h>\n\nvoid sort(int arr[], int n) {\n   int i, j, temp;\n   for (i = 0; i < n - 1; i++) {\n      for (j = 0; j < n - i - 1; j++) {\n         if (arr[j] > arr[j + 1]) {\n            temp = arr[j];\n            arr[j] = arr[j + 1];\n            arr[j + 1] = temp;\n         }\n      }\n   }\n}\n\nint main() {\n   int arr[] = {5, 2, 8, 4, 7};\n   int n = sizeof(arr) / sizeof(int);\n\n   sort(arr, n);\n\n   for (int i = 0; i < n; i++) {\n      printf(\"%d \", arr[i]);\n   }\n\n   return 0;\n}\n```",
    "thought": "这是关于C的问题",
    "command": "",
    "plugin": ""
}
```

### 例3-LeetCode：

```json
{
    "system": "Assistant扮演一名对话机器人。User每次输入一个问题，Assistant做出相应回答。不使用任何插件。",
    "source": "CodeGPT",
    "language": "Chinese",
    "user": "请用java完成以下题目：\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n \n\n示例 1：\n\n\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n\n示例 2：\n\n\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n\n\n示例 3：\n\n\n输入：nums = [3,3], target = 6\n输出：[0,1]\n\n\n \n\n提示：\n\n\n\t2 <= nums.length <= 104\n\t-109 <= nums[i] <= 109\n\t-109 <= target <= 109\n\t只会存在一个有效答案\n\n\n \n\n进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？\n",
    "assistant": "```java\nclass Solution {\n\n    public int[] twoSum(int[] nums, int target) {\n\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i< nums.length; i++){\n\n            int complement = target - nums[i];\n\n            if (map.containsKey(complement)){\n\n                return new int[]{map.get(complement), i};\n\n            }\n\n            map.put(nums[i], i);\n\n        }\n\n        return new int[]{};\n\n    }\n\n    \n\n}\n\n```",
    "thought": "这是关于数组、哈希表的问题",
    "command": "",
    "plugin": ""
}
```

### 例4-Text：

```json
{
    "system": "Assistant扮演一名对话机器人。User每次输入一个问题，Assistant做出相应回答。不使用任何插件。",
    "source": "CodeGPT",
    "language": "Chinese",
    "user": "变量的声明和定义有什么区别？",
    "assistant": "在C语言中声明变量：\n变量声明仅在编译时向编译器提供以给定类型和名称存在的变量的确定性，以便编译器继续进行进一步编译，而不需要该变量的所有细节。 在 C 语言中，当我们声明一个变量时，我们只将信息提供给编译器，但没有为它保留内存。 它只是一个引用，通过它我们只向编译器保证这个变量可以定义在函数内部或函数外部。\n注意：我们可以多次声明一个变量，但只定义一次。\n例如：\nextern int data;\nextern int foo(int, int);\nint fun(int, char); // extern can be omitted for function declarations\nC语言中变量的定义：\n定义是为变量分配存储空间的动作。 换句话说，可以说变量定义是一种方式来说明编译器在哪里以及为变量创建多少存储通常定义和声明同时发生但不几乎同时发生。\nint data;\nint foo(int, int) { }\n注意：当定义变量时，无需声明它，反之亦然不适用。",
    "thought": "",
    "command": "",
    "plugin": ""
}
```

### 注：

1. 本次公开的数据（V1-CN）只包含中文。对于其他语言，可以采用类似的方法用现有的LLM生成，也可以将我们公开的数据翻译成其他语言。
2. 本次公开的数据（V1-CN）未经人工校验，无法严格保证正确性、安全性。使用者需要对数据产生的结果负责。

## 主要贡献者

1. 朱晓萱, xxzhu22@m.fudan.edu.cn
2. 熊卓帜, zzxiong21@m.fudan.edu.cn
3. 张琳, linzhang22@m.fudan.edu.cn
4. 叶浩宁, hnye19@fudan.edu.cn
5. 顾洲洪, zhgu22@m.fudan.edu.cn
6. 李梓涵, zhli21@m.fudan.edu.cn
7. 蒋思航, tedsihangjiang@gmail.com
8. 冯红伟, hwfeng@fudan.edu.cn
9. 肖仰华, shawyh@fudan.edu.cn
10. [汪自力](https://commencement.github.io/), ziliwang.do@gmail.com
11. 杨东杰, djyang.tony@sjtu.edu.cn
12. [王树森](http://wangshusen.github.io/)，wssatzju@gmail.com

## 引用

如果你使用我们的方法或数据，请引用本GitHub Repo。

```
@misc{codegpt,
  author = {Xiaoxuan, Zhu and Zhuozhi, Xiong and Lin, Zhang and Haoning, Ye and Zhouhong, Gu and Zihan, Li and Sihang, Jiang and Hongwei, Feng and Yanghua, Xiao and Zili, Wang and Dongjie, Yang and Shusen, Wang},
  title = {CodeGPT: A Code-Related Dialogue Dataset Generated by GPT and for GPT},
  year = {2023},
  publisher = {GitHub},
  journal = {GitHub repository},
  howpublished = {\url{https://github.com/zxx000728/CodeGPT}},
}
```
